# For each species we will want to import then:
# :auto LOAD CSV WITH HEADERS FROM 'file:///dmel_GO_data_Mar15_24.tsv' AS dmelgo
# FIELDTERMINATOR '\t'
# CALL {
#     with dmelgo
#     MATCH (p:protein {id: dmelgo.FB_ID, txid: "txid7227"})-[pg1:ProGo]-(g1:go_term {id: dmelgo.GO_TERM})-[gg:GoGo]->(g2:go_term)
#     MERGE (p)-[pg2:ProGo]-(g2)
#     WHERE IS NULL pg2.relationship
#     SET pg2.relationship = "inferred_from_child"
# } IN TRANSACTIONS OF 1000 ROWS;
# 
# 
# Then iterate until no changes are made.
# MATCH (p:protein {txid: "txid7227"})-[pg1:ProGo]-(g1:go_term)-[gg:GoGo]->(g2:go_term)
# MERGE (p)-[pg2:ProGo]->(g2)
# WHERE IS NULL pg2.relationship
# SET pg2.relationship = "inferred_from_child"
# 
# 
# MATCH (p:protein {txid: "txid7227"})-[pg:ProGo]-(g:go_term)
# WHERE NOT pg.relationship = "inferred_from_child"
# RETURN COUNT(pg)

:auto LOAD CSV WITH HEADERS FROM 'file:///gene_association.fb' AS flygo
# FIELDTERMINATOR '\t'
# CALL {
#     with flygo
#     MATCH (n:protein {id: flygo.db_object_id, txid:"txid7227"})
#     MERGE (g:go_term {id: flygo.go_id})
#     MERGE (n)-[r:ProGo]-(g)
#     WITH g
#     OPTIONAL MATCH (g)-[:GoGo*1..1000000]->(pg:go_term)
#     MERGE (n)-[r:ProGo]-(pg)
# } IN TRANSACTIONS OF 1000 ROWS;

MATCH (p:protein {txid: 'txid7227'})-[:ProGo]-(g:go_term {id: "GO:0030177'})-[:GoGo*]->(g2)
WITH p, collect(g2) AS go_terms
UNWIND go_terms AS go_term
MERGE (p)-[:ProGo]->(go_term)
RETURN p, go_term


## Working Command for a Species
MATCH (p:protein {txid: 'txid7227'})-[:ProGo]-(g:go_term)
WITH p, collect(g) AS go_terms

UNWIND go_terms as go_input
MATCH (p)-[:ProGo]-(g:go_term {id: go_input.id})-[:GoGo*]->(g2)
WITH p, collect(distinct g2) AS parent_terms
UNWIND parent_terms AS parent_term

MERGE (p)-[:ProGo]-(parent_term)
